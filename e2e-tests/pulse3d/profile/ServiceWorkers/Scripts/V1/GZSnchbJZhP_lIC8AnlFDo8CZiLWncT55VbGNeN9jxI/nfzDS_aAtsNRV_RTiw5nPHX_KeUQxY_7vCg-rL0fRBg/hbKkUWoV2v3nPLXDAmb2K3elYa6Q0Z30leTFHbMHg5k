/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/jwt-decode/build/jwt-decode.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/jwt-decode/build/jwt-decode.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InvalidTokenError\": () => (/* binding */ n),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction e(e){this.message=e}e.prototype=new Error,e.prototype.name=\"InvalidCharacterError\";var r=\"undefined\"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,\"\");if(t.length%4==1)throw new e(\"'atob' failed: The string to be decoded is not correctly encoded.\");for(var n,o,a=0,i=0,c=\"\";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(o);return c};function t(e){var t=e.replace(/-/g,\"+\").replace(/_/g,\"/\");switch(t.length%4){case 0:break;case 2:t+=\"==\";break;case 3:t+=\"=\";break;default:throw\"Illegal base64url string!\"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t=\"0\"+t),\"%\"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if(\"string\"!=typeof e)throw new n(\"Invalid token specified\");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(\".\")[o]))}catch(e){throw new n(\"Invalid token specified: \"+e.message)}}n.prototype=new Error,n.prototype.name=\"InvalidTokenError\";/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (o);\n//# sourceMappingURL=jwt-decode.esm.js.map\n\n\n//# sourceURL=webpack://pulse/./node_modules/jwt-decode/build/jwt-decode.esm.js?");

/***/ }),

/***/ "./serviceWorker.js":
/*!**************************!*\
  !*** ./serviceWorker.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"accessToInternalsForTesting\": () => (/* binding */ accessToInternalsForTesting)\n/* harmony export */ });\n/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jwt-decode */ \"./node_modules/jwt-decode/build/jwt-decode.esm.js\");\n/* harmony import */ var async_mutex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! async-mutex */ \"./node_modules/async-mutex/index.mjs\");\n/* harmony import */ var _utils_labwareCalculations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/labwareCalculations */ \"./utils/labwareCalculations.js\");\n// Tanner (8/17/22): moved this file out of public/ since it is now processed by webpack\n// which will place the compiled output file into public/ instead. This uncompiled file does not\n// need to be included in any build steps, just the compiled webpack output\n\n\n\n\n\n/* Global state of SW */\nconst refreshMutex = new async_mutex__WEBPACK_IMPORTED_MODULE_1__.Mutex();\n\nlet accountType = null;\nlet usageQuota = null;\nlet ClientSource = null;\n\nconst cacheName = \"preloadedWellData\";\nconst twentyFourPlateDefinition = new _utils_labwareCalculations__WEBPACK_IMPORTED_MODULE_2__.WellTitle(4, 6);\nconst wellNames = Array(24)\n  .fill()\n  .map((_, idx) => twentyFourPlateDefinition.getWellNameFromIndex(idx));\n\nconst USERS_URL = new URLSearchParams(location.search).get(\"users_url\");\nconst PULSE3D_URL = new URLSearchParams(location.search).get(\"pulse3d_url\");\nconst USAGE_URLS = [\"/login\", \"/uploads\", \"/jobs\"];\n\n// add timestamps to logging\nconst originalLog = console.log;\n\nconsole.log = function () {\n  const time = new Date().toLocaleTimeString(\"en-US\", {\n    hour12: false,\n    hour: \"numeric\",\n    minute: \"numeric\",\n    second: \"numeric\",\n  });\n  originalLog(...[`[SW @ ${time}]`, ...arguments]);\n};\n\nconst setAccountType = (type) => {\n  accountType = type;\n};\n\nconst clearAccountType = () => {\n  accountType = null;\n};\n\nconst setUsageQuota = (usage) => {\n  usageQuota = usage;\n};\n\nconst clearUsageQuota = () => {\n  usageQuota = null;\n};\nconst tokens = {\n  access: null,\n  refresh: null,\n};\n\nlet logoutTimer = null;\n\nconst setTokens = ({ access, refresh }) => {\n  tokens.access = access.token;\n  tokens.refresh = refresh.token;\n\n  // clear old logout timer if one already exists\n  if (logoutTimer) {\n    clearTimeout(logoutTimer);\n  }\n  // set up new logout timer\n  const expTime = new Date((0,jwt_decode__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(tokens.refresh).exp * 1000);\n  const currentTime = new Date().getTime();\n  const millisBeforeLogOut = expTime - currentTime;\n  logoutTimer = setTimeout(sendLogoutMsg, millisBeforeLogOut);\n};\n\nconst clearTokens = () => {\n  tokens.access = null;\n  tokens.refresh = null;\n\n  clearTimeout(logoutTimer);\n};\n\nconst sendLogoutMsg = () => {\n  clearAccountInfo();\n  ClientSource.postMessage({ logout: true });\n  console.log(\"logout ping sent\");\n};\n\nconst clearAccountInfo = () => {\n  clearTokens();\n  clearAccountType();\n  clearUsageQuota();\n  // TODO change all console.log to console.debug and figure out how to enable debug logging\n  console.log(\"account info cleared\");\n};\n\n/* Request intercept functions */\n\nconst isLoginRequest = (url) => {\n  return url.pathname.includes(\"/login\");\n};\n\nconst isUpdateRequest = (url) => {\n  return url.pathname.includes(\"/account\");\n};\n\nconst isEmailRequest = (url) => {\n  return url.pathname.includes(\"/email\");\n};\n\nconst isWaveformDataRequest = (url) => {\n  // if it's a string, just check that it's a waveform data request\n  // else check if it's the initial request and will be passed url params instead\n  return url instanceof URL\n    ? url.pathname.includes(\"/waveform-data\")\n    : url.get(\"well_name\") === \"A1\" && url.get(\"peaks_valleys\");\n};\n\nconst modifyRequest = async (req, url) => {\n  // setup new headers\n  const headers = new Headers({\n    ...req.headers,\n    \"Content-Type\": \"application/json\",\n  });\n\n  if (!isLoginRequest(url) && tokens.access) {\n    // login request does not require the Authorization header,\n    // and if there are no tokens that should mean that no account is logged in\n    // and the request should fail with 403\n    headers.append(\"Authorization\", `Bearer ${tokens.access}`);\n  }\n\n  // apply new headers. Make sure to clone the original request obj if consuming the body by calling json()\n  // since it typically can only be consumed once\n  const modifiedReq = new Request(url, {\n    headers,\n    body: ![\"GET\", \"DELETE\"].includes(req.method) ? JSON.stringify(await req.clone().json()) : null,\n    method: req.method,\n  });\n\n  return modifiedReq;\n};\n\nconst handleRefreshRequest = async () => {\n  console.log(\"Requesting new tokens in handleRefreshRequest\");\n\n  let res = null;\n  try {\n    res = await fetch(`${USERS_URL}/refresh`, {\n      method: \"POST\",\n      body: JSON.stringify({}),\n      headers: { Authorization: `Bearer ${tokens.refresh}` },\n    });\n  } catch (e) {\n    console.log(\"ERROR in refresh req:\", e.message);\n    return { error: JSON.stringify(e.message) };\n  }\n\n  // set new tokens if refresh was successful\n  // tokens should get cleared later if refresh failed\n  if (res.status === 201) {\n    const newTokens = await res.json();\n    setTokens(newTokens);\n  }\n\n  return res.status;\n};\n\nconst requestWithRefresh = async (req, url) => {\n  const safeRequest = async () => {\n    try {\n      const modifiedReq = await modifyRequest(req, url);\n      return await fetch(modifiedReq);\n    } catch (e) {\n      return JSON.stringify(e.message);\n    }\n  };\n\n  let response = await safeRequest();\n\n  if (response.status === 401) {\n    // guard with mutex so multiple requests do not try to refresh simultaneously\n    const retryRequest = await refreshMutex.runExclusive(async () => {\n      // check remaining lifetime of access token\n      const nowNoMillis = Math.floor(Date.now() / 1000);\n      const accessTokenExp = (0,jwt_decode__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(tokens.access).exp;\n      if (accessTokenExp - nowNoMillis < 10) {\n        // refresh tokens since the access token less than 10 seconds away from expiring\n        const refreshResponseStatus = await handleRefreshRequest();\n        // only retry the original request if the refresh succeeds\n        return refreshResponseStatus === 201;\n      }\n      // since access token is not close to expiring, assume refresh was just triggered by a\n      // different request and try this request again\n      return true;\n    });\n    if (retryRequest) {\n      response = await safeRequest();\n    }\n  }\n\n  return response;\n};\n\nconst interceptResponse = async (req, url) => {\n  if (isLoginRequest(url)) {\n    const modifiedReq = await modifyRequest(req, url);\n    const response = await fetch(modifiedReq);\n    if (response.status === 200) {\n      // set tokens if login was successful\n      const data = await response.json();\n      setTokens(data.tokens);\n      let accountType = (0,jwt_decode__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(tokens.access).account_type; // either token will work here\n\n      if (accountType === \"customer\") {\n        // token types are 'user' and 'customer', but FE uses 'user' and 'admin'\n        accountType = \"admin\";\n      }\n\n      console.log(\"Setting account type:\", accountType);\n      setAccountType(accountType);\n      // sending usage at login, is separate from auth check request because it's not needed as often\n      setUsageQuota(data.usage_quota);\n    }\n\n    // send the response without the tokens so they are always contained within this service worker\n    return new Response(JSON.stringify({}), {\n      headers: response.headers,\n      status: response.status,\n      statusText: response.statusText,\n    });\n  } else {\n    const response = await requestWithRefresh(req, url);\n\n    // these URLs will return usage_error in the body with a 200 response\n    if (USAGE_URLS.includes(url.pathname) && req.method === \"POST\" && response.status == 200) {\n      const resBodyToCheck = await response.json();\n\n      // set the usage error to SW state to send in auth check, will return a 200 status\n      if (resBodyToCheck.error && resBodyToCheck.error === \"UsageError\") {\n        setUsageQuota(resBodyToCheck.message);\n      } else {\n        setUsageQuota(resBodyToCheck.usage_quota);\n      }\n      // make sure to send the rest of the body for the uploads-form to handle response itself\n      return new Response(JSON.stringify(resBodyToCheck));\n    } else if (url.pathname.includes(\"logout\")) {\n      // just clear account info if user purposefully logs out\n      clearAccountInfo();\n    } else if (response.status === 401 || response.status === 403) {\n      // if any other request receives an unauthorized or forbidden error code, send logout ping (this fn will also clear account info)\n      sendLogoutMsg();\n    } else if (isWaveformDataRequest(url)) {\n      caches.open(cacheName).then(async (cache) => {\n        if (response) cache.put(req, response.clone());\n      });\n    }\n\n    return response.clone();\n  }\n};\n\nconst startPreloadingWellData = (uploadId, jobId) => {\n  try {\n    // remove A1 as that's loaded first separately\n    const [, ...remainingWells] = wellNames;\n\n    for (const [idx, well] of Object.entries(remainingWells)) {\n      setTimeout(() => {\n        const destURL = new URL(\n          `${PULSE3D_URL}/jobs/waveform-data?upload_id=${uploadId}&job_id=${jobId}&peaks_valleys=false&well_name=${well}`\n        );\n\n        const newReq = new Request(destURL);\n        caches.open(cacheName).then(async (cache) => {\n          // Go to the cache first\n          return cache.match(newReq.url).then(async (cachedResponse) => {\n            // Return a cached response if we have one\n            if (!cachedResponse) {\n              // Otherwise, hit the network\n              interceptResponse(newReq, destURL);\n            }\n          });\n        });\n      }, 2000 * idx);\n    }\n  } catch (e) {\n    console.log(\"Error grabbing preloaded data: \" + e);\n  }\n};\n\n/* Event listeners of SW */\n\nself.addEventListener(\"install\", (event) => {\n  event.waitUntil(self.skipWaiting());\n  console.log(\"Service worker installed!\");\n});\n\nself.addEventListener(\"activate\", (event) => {\n  // delete any previous cache from previous sessions\n  event.waitUntil(\n    caches.keys().then(function (cacheNames) {\n      return Promise.all(\n        cacheNames.map(function (cacheName) {\n          console.log(\"Deleting cache for: \", cacheName);\n          return caches.delete(cacheName);\n        })\n      );\n    })\n  );\n  console.log(\"Service worker ready!\");\n});\n// Intercept all fetch requests\nself.addEventListener(\"fetch\", async (e) => {\n  let destURL = new URL(e.request.url);\n  const urlParams = new URLSearchParams(destURL.search);\n\n  if (\n    (e.request.url.includes(USERS_URL) || e.request.url.includes(PULSE3D_URL)) &&\n    !isEmailRequest(destURL) && // this request doesn't depend on a token\n    !isUpdateRequest(destURL) // we don't need to intercept verify request because it's handling own token\n  ) {\n    // only intercept requests to pulse3d and user APIs\n    e.respondWith(\n      caches.open(cacheName).then(async (cache) => {\n        // Go to the cache first\n        const cachedResponse = await cache.match(e.request.url);\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n        // Otherwise, hit the network\n        const response = await interceptResponse(e.request, destURL);\n        // before returning response, check if you need to preload other wells\n        // this needs to go after interceptResponse so that the initial A1 data gets returned first and not blocked by other requests\n        if (isWaveformDataRequest(urlParams)) {\n          const jobId = urlParams.get(\"job_id\");\n          const uploadId = urlParams.get(\"upload_id\");\n          startPreloadingWellData(uploadId, jobId);\n        }\n\n        return response;\n      })\n    );\n  } else {\n    e.respondWith(fetch(e.request));\n  }\n});\n\nself.onmessage = ({ data, source }) => {\n  ClientSource = source;\n  if (data.msgType === \"authCheck\") {\n    console.log(\"Returning authentication check\");\n    source.postMessage({\n      isLoggedIn: tokens.access !== null,\n      accountType,\n      routerPathname: data.routerPathname,\n      usageQuota,\n    });\n  } else if (data.msgType === \"stayAlive\") {\n    // TODO should have this do something else so that there isn't a log msg produced every 20 seconds\n    console.log(\"Staying alive\");\n  } else if (data.msgType === \"clearData\") {\n    // a way for the FE components to force clear all stored data in the service worker\n    console.log(\"Recieved clear message type to clear account info\");\n    clearAccountInfo();\n  }\n};\n\nconst accessToInternalsForTesting = {\n  tokens,\n  logoutTimer,\n  ClientSource,\n  accountType,\n};\n\n\n//# sourceURL=webpack://pulse/./serviceWorker.js?");

/***/ }),

/***/ "./utils/labwareCalculations.js":
/*!**************************************!*\
  !*** ./utils/labwareCalculations.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WellTitle\": () => (/* binding */ WellTitle)\n/* harmony export */ });\n/**\n * Add an extra leading zero when needed to the number (for use in the well name)\n *\n * @param {int} columnIndex - The column index within the labware\n * @param {bool} padding - Whether to zero-pad the number in the well name\n * @return {string}\n */\nfunction _getFormattedColumnString(columnIndex, padding) {\n  const columnNumber = columnIndex + 1;\n  if (padding) {\n    return \"0\" + columnNumber;\n  } else {\n    return columnNumber.toString();\n  }\n}\n\n/** Allows calculations to convert between row, column, well index, and well name for Labware Definitions */\nclass WellTitle {\n  /**\n   * Take pixel coordinates from a drawing and convert it back to the x/y numerical values that should have been used to generate those pixel coordinates.\n   *\n   * @param {int} numRows - The number of rows in the labware/plate\n   * @param {int} numCols - The number of columns in the labware/plate\n   */\n  constructor(numRows, numCols) {\n    this.numRows = numRows;\n    this.numCols = numCols;\n  }\n\n  /**\n   * Take pixel coordinates from a drawing and convert it back to the x/y numerical values that should have been used to generate those pixel coordinates.\n   *\n   * @throws {Error} If row or column index outside acceptable range (0-36 and 0-18) up to a 1536 well plate.\n   */\n  validateRowColumnCounts() {\n    if (this.numRows < 1 || this.numRows > 18) {\n      throw new Error(`Invalid number of rows: ${this.numRows}`);\n    }\n    if (this.numCols < 1 || this.numCols > 36) {\n      throw new Error(`Invalid number of columns: ${this.numCols}`);\n    }\n  }\n\n  /**\n   * Get the row and column indices from the well index\n   *\n   * @param {int} wellIndex - The well index within the labware\n   * @return {Object} containing both the row index and well index (integers)\n   */\n  getRowColumnFromWellIndex(wellIndex) {\n    this.validateRowColumnCounts();\n    return {\n      row: wellIndex % this.numRows,\n      col: Math.floor(wellIndex / this.numRows),\n    };\n  }\n\n  /**\n   * Get the well name from the row and column indices\n   *\n   * @param {int} rowIndex - The row index within the labware\n   * @param {int} columnIndex - The column index within the labware\n   * @param {bool} padding - Whether to zero-pad the number in the well name\n   * @return {string}\n   */\n  getWellNameFromRowColumn(rowIndex, columnIndex, padding) {\n    const rowChar = String.fromCharCode(65 + rowIndex);\n    const columnChar = _getFormattedColumnString(columnIndex, padding);\n    return rowChar + columnChar;\n  }\n\n  /**\n   * Get the well index from the row and column indices\n   *\n   * @param {int} rowIndex - The row index within the labware\n   * @param {int} columnIndex - The column index within the labware\n   * @return {int}\n   */\n  getWellIndexFromRowColumn(rowIndex, columnIndex) {\n    return columnIndex * this.numRows + rowIndex;\n  }\n\n  /**\n   * Get the alphanumeric well name from the well index\n   *\n   * @param {int} wellIndex - The well index within the labware\n   * @param {bool} padding - Whether to zero-pad the number in the well name\n   * @return {string} containing both the row index and well index (integers)\n   */\n  getWellNameFromIndex(wellIndex, padding) {\n    const { row, col } = this.getRowColumnFromWellIndex(wellIndex);\n    return this.getWellNameFromRowColumn(row, col, padding);\n  }\n\n  /**\n   * Get the well index from well name\n   *\n   * @param {string} wellName\n   * @returns {int}\n   */\n  getWellIndexFromName(wellName) {\n    const row = wellName.charCodeAt(0) - \"A\".charCodeAt(0);\n    const col = parseInt(wellName.slice(1)) - 1;\n    return this.getWellIndexFromRowColumn(row, col);\n  }\n}\n\n\n//# sourceURL=webpack://pulse/./utils/labwareCalculations.js?");

/***/ }),

/***/ "./node_modules/async-mutex/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/async-mutex/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"E_ALREADY_LOCKED\": () => (/* binding */ E_ALREADY_LOCKED),\n/* harmony export */   \"E_CANCELED\": () => (/* binding */ E_CANCELED),\n/* harmony export */   \"E_TIMEOUT\": () => (/* binding */ E_TIMEOUT),\n/* harmony export */   \"Mutex\": () => (/* binding */ Mutex),\n/* harmony export */   \"Semaphore\": () => (/* binding */ Semaphore),\n/* harmony export */   \"tryAcquire\": () => (/* binding */ tryAcquire),\n/* harmony export */   \"withTimeout\": () => (/* binding */ withTimeout)\n/* harmony export */ });\nconst E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_maxConcurrency, _cancelError = E_CANCELED) {\n        this._maxConcurrency = _maxConcurrency;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._waiters = [];\n        if (_maxConcurrency <= 0) {\n            throw new Error('semaphore must be initialized to a positive value');\n        }\n        this._value = _maxConcurrency;\n    }\n    acquire() {\n        const locked = this.isLocked();\n        const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));\n        if (!locked)\n            this._dispatch();\n        return ticketPromise;\n    }\n    runExclusive(callback) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire();\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock() {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            if (!this.isLocked()) {\n                return Promise.resolve();\n            }\n            const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));\n            return waitPromise;\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        if (this._maxConcurrency > 1) {\n            throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n        }\n        if (this._currentReleaser) {\n            const releaser = this._currentReleaser;\n            this._currentReleaser = undefined;\n            releaser();\n        }\n    }\n    cancel() {\n        this._queue.forEach((ticket) => ticket.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatch() {\n        const nextTicket = this._queue.shift();\n        if (!nextTicket)\n            return;\n        let released = false;\n        this._currentReleaser = () => {\n            if (released)\n                return;\n            released = true;\n            this._value++;\n            this._resolveWaiters();\n            this._dispatch();\n        };\n        nextTicket.resolve([this._value--, this._currentReleaser]);\n    }\n    _resolveWaiters() {\n        this._waiters.forEach((waiter) => waiter.resolve());\n        this._waiters = [];\n    }\n}\n\nvar __awaiter$1 = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            let isTimeout = false;\n            const handle = setTimeout(() => {\n                isTimeout = true;\n                reject(timeoutError);\n            }, timeout);\n            try {\n                const ticket = yield sync.acquire();\n                if (isTimeout) {\n                    const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                    release();\n                }\n                else {\n                    clearTimeout(handle);\n                    resolve(ticket);\n                }\n            }\n            catch (e) {\n                if (!isTimeout) {\n                    clearTimeout(handle);\n                    reject(e);\n                }\n            }\n        })),\n        runExclusive(callback) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire();\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n        release() {\n            sync.release();\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: () => sync.waitForUnlock(),\n        isLocked: () => sync.isLocked(),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\n\n\n\n//# sourceURL=webpack://pulse/./node_modules/async-mutex/index.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/
/************************************************************************/
/******/
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./serviceWorker.js");
/******/
/******/ })()
;